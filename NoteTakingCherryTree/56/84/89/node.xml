<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <node unique_id="89" master_id="0" name="anotation" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1720555688" ts_lastsave="1720556296">
    <rich_text> @</rich_text>
    <rich_text weight="heavy">Entity</rich_text>
    <rich_text> // Marks the class as a database entity
@</rich_text>
    <rich_text weight="heavy">Table</rich_text>
    <rich_text>(name = "user") // Specifies the table name in the database
@</rich_text>
    <rich_text weight="heavy">NamedQuery</rich_text>
    <rich_text>(
    name = "User.findByUsername",
    query = "SELECT u FROM User u WHERE u.username = :username"
) // Defines a named query to find a user by username
public class User {

    @</rich_text>
    <rich_text weight="heavy">Id</rich_text>
    <rich_text> // Marks the field as a primary key
    @</rich_text>
    <rich_text weight="heavy">GeneratedValue</rich_text>
    <rich_text>(strategy = GenerationType.IDENTITY) // Specifies that the primary key is auto-generated by the database (using auto-increment in MySQL, PostgreSQL, etc.)
    private Long id;

    @</rich_text>
    <rich_text weight="heavy">Column</rich_text>
    <rich_text>(name = "username", nullable = false, unique = true) // Specifies column details for the 'username' field
    private String username;

    @Column(name = "password", nullable = false) // Specifies column details for the 'password' field
    private String password;

    @</rich_text>
    <rich_text weight="heavy">Temporal</rich_text>
    <rich_text>(TemporalType.DATE) // Specifies the temporal type for a date field (in this case, 'birthDate')
    private Date birthDate;

    @</rich_text>
    <rich_text weight="heavy">Lob</rich_text>
    <rich_text> // Marks the field as a large object (typically used for storing large text or binary data)
    private String bio;

    @</rich_text>
    <rich_text weight="heavy">OneToOne</rich_text>
    <rich_text> // Defines a one-to-one relationship with the 'Profile' entity
    @</rich_text>
    <rich_text weight="heavy">JoinColumn</rich_text>
    <rich_text>(name = "profile_id") // Specifies the foreign key column name in the database
    private Profile profile;

    @</rich_text>
    <rich_text weight="heavy">OneToMany</rich_text>
    <rich_text>(mappedBy = "user") // Defines a one-to-many relationship with the 'Post' entity, where 'user' is the field in the 'Post' entity that maps back to this 'User' entity
    private List&lt;Post&gt; posts;

    @</rich_text>
    <rich_text weight="heavy">ManyToOne</rich_text>
    <rich_text> // Defines a many-to-one relationship with the 'Department' entity
    @JoinColumn(name = "department_id") // Specifies the foreign key column name in the database
    private Department department;

    @</rich_text>
    <rich_text weight="heavy">ManyToMany</rich_text>
    <rich_text> // Defines a many-to-many relationship with the 'Role' entity
    @JoinTable(
        name = "user_role", // Specifies the join table name in the database
        joinColumns = @JoinColumn(name = "user_id"), // Specifies the foreign key column name for this 'User' entity
        inverseJoinColumns = @JoinColumn(name = "role_id") // Specifies the foreign key column name for the 'Role' entity
    )
    private Set&lt;Role&gt; roles;

    @</rich_text>
    <rich_text weight="heavy">Transient</rich_text>
    <rich_text> // Ignores the 'temporaryField' for persistence (it won't be stored in the database)
    private String temporaryField;
		
		Purpose: The @Transient annotation is used to indicate that a field should not be persisted in the database. When an entity is saved, updated, or retrieved, the fields marked with @Transient will be ignored by JPA.
		
    @</rich_text>
    <rich_text weight="heavy">Embedded</rich_text>
    <rich_text> // Embeds the 'Address' embeddable class into this entity
    private Address address;

	 Explanation: Indicates that the annotated field (address in this case) is an embedded object. An embedded object is stored as part of the owning entity's table.Usage: Useful when you have a complex object (Address class) that logically belongs to another entity (User), but you want it to be stored together in the same table.
	
    @</rich_text>
    <rich_text weight="heavy">Embedded</rich_text>
    <rich_text>
    @</rich_text>
    <rich_text weight="heavy">AttributeOverride</rich_text>
    <rich_text>(name = "street", column = @Column(name = "billing_street")) // Overrides the column mapping for the 'street' attribute of the 'billingAddress' embedded object
    private Address billingAddress;

    // Getters and setters
}


</rich_text>
    <rich_text weight="heavy">Derived Query Methods</rich_text>
    <rich_text>: Spring Data JPA can create queries based on method names.
</rich_text>
    <rich_text weight="heavy">@Query Annotation</rich_text>
    <rich_text>: Write custom JPQL or SQL queries directly in the repository interface.
</rich_text>
    <rich_text weight="heavy">Named Queries</rich_text>
    <rich_text>: Define named queries in the entity class and reference them in the repository.

	 import org.springframework.data.jpa.repository.JpaRepository;

	public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
		// This will automatically generate the query "SELECT u FROM User u WHERE u.username = ?1"
		User </rich_text>
    <rich_text weight="heavy">findByUsername</rich_text>
    <rich_text>(String username);
	}
	
		import org.springframework.data.jpa.repository.JpaRepository;
	import org.springframework.data.jpa.repository.Query;
	import org.springframework.data.repository.query.Param;

	public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
		
		@</rich_text>
    <rich_text weight="heavy">Query</rich_text>
    <rich_text>("SELECT u FROM User u WHERE u.username = :username")
		User findByUsername(@Param("username") String username);
	}
	 import javax.persistence.*;

@Entity
@Table(name = "user")
@NamedQuery(
    name = "User.findByUsername",
    query = "SELECT u FROM User u WHERE u.username = :username"
)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username", nullable = false, unique = true)
    private String username;

    @Column(name = "password", nullable = false)
    private String password;

    // Getters and setters
}


import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    
    @</rich_text>
    <rich_text weight="heavy">Query</rich_text>
    <rich_text>(name = "User.findByUsername")
    User </rich_text>
    <rich_text weight="heavy">findByUsername</rich_text>
    <rich_text>(@Param("username") String username);
}
public User findUserByUsername(String username) {
    </rich_text>
    <rich_text weight="heavy">EntityManager em = getEntityManager();</rich_text>
    <rich_text>
    return </rich_text>
    <rich_text weight="heavy">em.createNamedQuery</rich_text>
    <rich_text>("User.findByUsername", User.class)
             .setParameter("username", username)
             .</rich_text>
    <rich_text weight="heavy">getSingleResult</rich_text>
    <rich_text>();
}


 </rich_text>
    <rich_text weight="heavy">ExplanationMethod</rich_text>
    <rich_text> Declaration:public User findUserByUsername(String username)This is a public method that returns a User object.
 It takes a String parameter called username.
 Getting the EntityManager:EntityManager em = getEntityManager();EntityManager is used to interact with the persistence context.
 getEntityManager() is a method that returns an instance of EntityManager. (This method is not shown in your code, but it's assumed to be defined elsewhere in your class.)Creating a Named Query:return em.
 createNamedQuery("User.findByUsername", User.class)createNamedQuery is a method of EntityManager that creates a query using a named query defined in the User entity.
 "User.findByUsername" is the name of the query defined with the @NamedQuery annotation in the User entity class.User.class specifies that the result of the query should be mapped to the User entity.
 Setting the Parameter:.setParameter("username", username)setParameter is used to set the value of the named parameter :username in the query.The first argument is the name of the parameter in the query ("username").
 The second argument is the value to bind to the parameter (username, which is the method argument).Executing the Query:.getSingleResult();
 getSingleResult executes the query and returns a single result.If the query finds a matching user, it returns the User entity.If no matching user is found, it throws a NoResultException.If more than one result is found, it throws a NonUniqueResultException.

public class UserService {

    @PersistenceContext
    private EntityManager em;

    public List&lt;User&gt; findAllUsers() {
        TypedQuery&lt;User&gt; query = em.createNamedQuery("User.findAll", User.class);
        return query.getResultList();
    }
}

</rich_text>
    <rich_text weight="heavy">Explanation EntityManager</rich_text>
    <rich_text> Injection:@PersistenceContext
private EntityManager em;
@PersistenceContext injects the EntityManager into the UserService class.
Creating the Named Query:TypedQuery&lt;User&gt; query = em.createNamedQuery("User.findAll", User.class);
createNamedQuery creates a query using the named query User.findAll.User.class specifies the result type of the query.
Executing the Query:return query.getResultList();
getResultList executes the query and returns the result as a list of User entities.</rich_text>
  </node>
</cherrytree>
