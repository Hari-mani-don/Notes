<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>NoteTakingCheryTree</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title level-1'>JavaProjectsDocument</h1><br/></div><div class='page'><h1 class='title level-2'>ControllerClass</h1><br/><p><h2>	Controller class</h2><h2></h2></p><p><h2>	================</h2><h2></h2></p><p><h2></h2><h2></h2></p><p><h2>		1. interface venam , interface complicate use our controller class</h2><h2></h2></p><p><h2>		2. class name must functionality name and end suffix controller add.</h2><h2></h2></p><p><h2>		3. class only have that class related methods only.</h2><h2></h2></p><p><h2>		4. single responsibility pattern compare to groupin which groupin is best practice and maintain code.</h2><h2></h2></p><p><h2>		6. method name prifix with &quot;handle&quot; and action name .</h2><h2></h2></p><p><h2>		7. controller class method return type RespnseEntity is best aproch ,</h2><h2></h2></p><p><h2>		8. each method have single action only.</h2><h2></h2></p><p><h2>		9. class name prefix with name customer, client or corporate afte functionality Name for example</h2><h2></h2></p><p><h2>		   &quot;CustomerHomeController&quot;,&quot;UserPaymentController&quot;</h2><h2></h2></p><p><h2>		10. method name prefix with action and add name of the class prefix like &quot; addCustomer&quot; , &quot;processUserPayment&quot;</h2><h2></h2></p><p><h2>		11.Exception Handling class also write in controller class.</h2><h2></h2></p><p><h2></h2><h2></h2></p><p><h2>example:</h2><h2></h2></p><p><h2>=======</h2><h2></h2></p><p><h2></h2><h1>	</h1><img src="images/9-1.png" alt="images/9-1.png" />   </p><p>	</p><p>	</p><p>	</p></div><div class='page'><h1 class='title level-2'>ServiceClass</h1><br/><p><h2>Service</h2><h2></h2></p><p><h2>=============</h2><h2></h2></p><p><h2>	SOLID principle</h2><h2></h2></p><p><h2>	========================</h2><h2></h2></p><p><h2>	</h2><h2></h2></p><p><h2>	S - single responsiblitiy that is class have only one functionality.</h2><h2></h2></p><p><h2>	O - Open / Closed principle that is existing modules add new functioality that is add new class and existing module without affect </h2><h2></h2></p><p><h2>		any functionality. </h2><h2></h2></p><p><h2>	L - liskov priciple that is superclass method implement class compolsory override and also override method use otherwise method not </h2><h2></h2></p><p><h2>		using it define another interface.</h2><h2></h2></p><p><h2>	I - Interface segregation that is every interface have single method or multiple that functionality related group of method.  </h2><h2></h2></p><p><h2>	D - dependency injection which means loose coupling</h2><h2></h2></p><p><h2></h2></p></div><div class='page'><h1 class='title level-2'>RepositoryClass</h1><br/><p><h1>repository</h1><h1></h1></p><p><h1>===========</h1><h1></h1></p><p><h1>	just interface only create in entity class related. </h1></p></div><div class='page'><h1 class='title level-2'>ProjectStructure</h1><br/><p><h1>Project Structure</h1><h1></h1></p><p><h1>==========</h1></p><p></p><p><img src="images/12-1.png" alt="images/12-1.png" /></p></div><div class='page'><h1 class='title level-2'>EndPoint Name</h1><br/><p><h1>EndPoint Name</h1><h1></h1></p><p><h1>=============</h1><h1></h1></p><p><h1></h1><h2>	1.End point name compalsory noun that is name of things and also provide plurals forms like &quot;users&quot;</h2><h2></h2></p><p><h2>	2.user is singular which means we don&#39;t write b&#39;z in every case json provide collection of users so that complexity it will create.</h2><h2></h2></p><p><h2>	</h2></p><p>	</p><p><h2>	Products:</h2><h2></h2></p><p><h2>===========</h2><h2></h2></p><p><h2></h2><h2></h2></p><p><h2>	1.GET /products - Retrieve a list of products</h2><h2></h2></p><p><h2>	2.GET /products/{id} - Retrieve a specific product</h2><h2></h2></p><p><h2>	3.POST /products - Create a new product</h2><h2></h2></p><p><h2>	4.PUT /products/{id} - Update an existing product</h2><h2></h2></p><p><h2>	5.DELETE /products/{id} - Delete a specific product</h2><h2></h2></p><p><h2>	6.GET /products/search?query={keyword} - Search for products based on a keyword</h2></p><p>	</p><p>	<img src="images/13-1.png" alt="images/13-1.png" /></p></div><div class='page'><h1 class='title level-2'>Segregation Principle</h1><br/><p><h1>Segregation principle  ??????</h1><h1></h1></p><p><h1>=========================</h1><h2></h2></p><p><h2>       1.Directly Implement Interface: </h2><h2></h2></p><p><h2>       -------------------------------</h2><h2></h2></p><p><h2>       that class is only have that functionality gor for direct implement.example notification is a method </h2><h2></h2></p><p><h2>		implement email , email related functionality write. this is not have shared logic.</h2><h2></h2></p><p><h2></h2><h2></h2></p><p><h2>       2.Use Common Class for Shared Logic:</h2><h2></h2></p><p><h2>       ---------------------------------------</h2><h2></h2></p><p><h2>        that is common shared logic write and aggregation used to get common logic also override common logic.</h2></p><p>        </p><p>        </p><p><h2>        Example</h2></p><p>        -------------------------</p><p><h3>        public interface ProductService {</h3><h3></h3></p><p><h3>	    List&lt;Product&gt; getAllProducts();</h3><h3></h3></p><p><h3>	    Product getProductById(String id);</h3><h3></h3></p><p><h3>	    Product createProduct(Product product);</h3><h3></h3></p><p><h3>	    Product updateProduct(String id, Product product);</h3><h3></h3></p><p><h3>	    void deleteProduct(String id);</h3><h3></h3></p><p><h3>	    List&lt;Review&gt; getProductReviews(String id);</h3><h3></h3></p><p><h3>	    Review addReviewToProduct(String id, Review review);</h3><h3></h3></p><p><h3>	    List&lt;Rating&gt; getProductRatings(String id);</h3><h3></h3></p><p><h3>	    Rating addRatingToProduct(String id, Rating rating);</h3><h3></h3></p><p><h3>	    List&lt;Product&gt; searchProducts(String query);</h3><h3></h3></p><p><h3>	}</h3><h3></h3></p><p><h3>	</h3><h3></h3></p><p><h3>	public interface RatingService {</h3><h3></h3></p><p><h3>	    List&lt;Rating&gt; getProductRatings(String id);</h3><h3></h3></p><p><h3>	    Rating addRatingToProduct(String id, Rating rating);</h3><h3></h3></p><p><h3>	}</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>	public interface ProductSearchService {</h3><h3></h3></p><p><h3>	    List&lt;Product&gt; searchProducts(String query);</h3><h3></h3></p><p><h3>	}</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>	public interface ReviewService {</h3><h3></h3></p><p><h3>	    List&lt;Review&gt; getProductReviews(String id);</h3><h3></h3></p><p><h3>	    Review addReviewToProduct(String id, Review review);</h3><h3></h3></p><p><h3>	}</h3></p></div><div class='page'><h1 class='title level-2'>Abstract Clsss</h1><br/><p><h2>Abstract class when use</h2><h2></h2></p><p><h2>=========================</h2><h2></h2></p><p><h2>		abstract class use pannanumna common method functionality is not change extend any class like static variable provide common thing</h2><h2></h2></p><p><h2>		same in abstract method after some dynamic method also add . by extend any class compalsory implement and alredy implemt abstract </h2><h2></h2></p><p><h2>		method just using. </h2><h2></h2></p><p><h2></h2></p></div><div class='page'><h1 class='title level-2'>Java Doc</h1><br/><p><h2>java doc</h2><h2></h2></p><p><h2>=========</h2><h2></h2></p><p><h2>	class:</h2><h2></h2></p><p><h2>	========</h2><h2></h2></p><p><h2>	write class name same as functionality name may need not write doc. </h2><h2></h2></p><p><h2>	</h2><h2></h2></p><p><h2>	methods</h2><h2></h2></p><p><h2>	==========</h2><h2></h2></p><p><h2>	write method name same as action name however write complex logic place may write doc.</h2></p><p>	</p><p>	</p><p>	</p><p>	<img src="images/16-1.png" alt="images/16-1.png" />      </p><p>	</p><p>	</p><p><h1>	Common Comments</h1></p><p><h1>	-------------------------------</h1></p><p>																	</p><p>																	</p><p>									<img src="images/16-2.png" alt="images/16-2.png" />      </p></div><div class='page'><h1 class='title level-2'>HibernetQuery</h1><br/><p><h1>Query</h1></p><p>--------------</p><p></p><p><h2>default methods:</h2><h2></h2></p><p><h2>	----------------</h2><h2></h2></p><p><h2>		1. 	save(S entity):</h2><h2></h2></p><p><h2>		2. 	findOne(ID id):</h2><h2></h2></p><p><h2>		3. 	findAll():</h2><h2></h2></p><p><h2>		4. 	existsById(ID id):</h2><h2></h2></p><p><h2>		5. 	findAllById(Iterable&lt;ID&gt; ids):</h2><h2></h2></p><p><h2>		6. 	count():</h2><h2></h2></p><p><h2>		7. 	deleteById(ID id):	</h2><h2></h2></p><p><h2>		8. 	delete(T entity):</h2></p><p>	</p><p></p><p></p><p></p><p></p><p><img src="images/17-1.png" alt="images/17-1.png" /></p><p></p><p></p><p></p><p>       				<h3>	1. 	   	findByFirstNameAndLastName(String firstName, String lastName): </h3><h3></h3></p><p><h3>						2. 		findByAgeGreaterThan(int age): </h3><h3></h3></p><p><h3>						3. 		findBySalaryLessThan(double salary): </h3><h3></h3></p><p><h3>						4. 		findByCity(String city): </h3><h3></h3></p><p><h3>						5. 		findByState(String state): </h3><h3></h3></p><p><h3>						6. 		findByCountry(String country): </h3><h3></h3></p><p><h3>						7. 		findByFirstNameOrLastName(String firstName, String lastName): </h3><h3></h3></p><p><h3>						8. 		findByAgeLessThanEqual(int age): </h3><h3></h3></p><p><h3>						9. 		findByActiveTrue(): </h3><h3></h3></p><p><h3>						10. 		findByActiveFalse(): </h3><h3></h3></p><p><h3>						11. 		findByFirstNameIgnoreCase(String firstName): </h3><h3></h3></p><p><h3>						12. 		findByLastNameIgnoreCase(String lastName): </h3><h3></h3></p><p><h3>						13. 		findByFirstNameLike(String pattern): </h3><h3></h3></p><p><h3>						14. 		findByLastNameLike(String pattern): </h3><h3></h3></p><p><h3>						15. 		findByFirstNameStartingWith(String prefix): </h3><h3></h3></p><p><h3>						16. 		findByLastNameEndingWith(String suffix): </h3><h3></h3></p><p><h3>						17. 		findByDateOfBirthBetween(Date startDate, Date endDate): </h3><h3></h3></p><p><h3>						18. 		findByFirstNameOrderByLastNameAsc(String firstName): </h3><h3></h3></p><p><h3>						19. 		findByLastNameOrderByFirstNameDesc(String lastName): </h3><h3></h3></p><p><h3>						20. 		findByAgeGreaterThanEqualAndCity(int age, String city): </h3><h3></h3></p><p><h3>						21. 		findByStateAndCountry(String state, String country): </h3><h3></h3></p><p><h3>						22. 		findByFirstNameNotNull(): </h3><h3></h3></p><p><h3>						23. 		findByLastNameNull(): </h3><h3></h3></p><p><h3>						24. 		findByDateOfBirthNotNull(): </h3><h3></h3></p><p><h3>						25. 		findByAgeIn(Collection&lt;Integer&gt; ages): </h3><h3></h3></p><p><h3>						26. 		findBySalaryNot(double salary): </h3><h3></h3></p><p><h3>						27. 		findByFirstNameAndActiveTrue(String firstName): </h3><h3></h3></p><p><h3>						28. 		findByLastNameAndActiveFalse(String lastName): </h3><h3></h3></p><p><h3>						29. 		findByCityOrState(String city, String state):</h3><h3></h3></p><p><h3>						30. 		findByCountryNot(String country):</h3><h3></h3></p><p><h3>						31. 		findByFirstNameContainingIgnoreCase(String keyword): </h3><h3></h3></p><p><h3>						32. 		findByLastNameContainingIgnoreCase(String keyword): </h3><h3></h3></p><p><h3>						33. 		findByAgeGreaterThanEqualAndAgeLessThan(int minAge, int maxAge): </h3><h3></h3></p><p><h3>						34. 		findByDateOfBirthBefore(Date date): </h3><h3></h3></p><p><h3>						35. 		findByDateOfBirthAfter(Date date): </h3><h3></h3></p><p><h3>						36. 		findByDateOfBirthNotNullAndActiveTrue(): </h3><h3></h3></p><p><h3>						37. 		findByFirstNameAndLastNameAndAge(String firstName, String lastName, int age): </h3><h3></h3></p><p><h3>						38. 		findByLastNameNotIn(Collection&lt;String&gt; lastNames): </h3><h3></h3></p><p><h3>						39. 		findByAgeGreaterThanAndCityOrState(int age, String city, String state): </h3><h3></h3></p><p><h3>						40. 		findBySalaryGreaterThanEqualAndSalaryLessThan(double minSalary, double maxSalary): </h3><h3></h3></p><p><h3>						41. 		findByActiveTrueAndCityNotNull(): </h3><h3></h3></p><p><h3>						42. 		findByActiveFalseAndStateNull(): </h3><h3></h3></p><p><h3>						43. 		findByDateOfBirthBetweenAndCountry(Date startDate, Date endDate, String country): </h3><h3></h3></p><p><h3>						44. 		findByFirstNameIgnoreCaseOrLastNameIgnoreCase(String firstName, String lastName): </h3><h3></h3></p><p><h3>						45. 		findByCityStartingWithIgnoreCase(String prefix):</h3><h3></h3></p><p><h3>						46. 		findByStateEndingWithIgnoreCase(String suffix): </h3><h3></h3></p><p><h3>						47. 		findByCountryIn(Collection&lt;String&gt; countries):</h3><h3></h3></p><p><h3>						48. 		findByFirstNameNotNullAndLastNameNotNull():</h3><h3></h3></p><p><h3>						49. 		findByAgeLessThanEqualAndCityOrState(int age, String city, String state): </h3><h3></h3></p><p><h3>						50. 		findBySalaryGreaterThanEqualOrSalaryLessThanEqual(double minSalary, double maxSalary):</h3><h3></h3></p><p><h3>	</h3><h3></h3></p><p><h3>	</h3><h3></h3></p><p><h3>	</h3><h2>																			common criteria keywords</h2><h2></h2></p><p><h2>    -------------------------------------</h2></p><p>	   <img src="images/17-2.png" alt="images/17-2.png" /><img src="images/17-3.png" alt="images/17-3.png" /></p><p>      <img src="images/17-4.png" alt="images/17-4.png" /><img src="images/17-5.png" alt="images/17-5.png" />            </p><p>      <img src="images/17-6.png" alt="images/17-6.png" /><img src="images/17-7.png" alt="images/17-7.png" /></p><p>	   </p><p>                  </p><p>      </p><p></p><p></p><p></p><p><img src="images/17-8.png" alt="images/17-8.png" /></p><p></p><p></p><p></p><p></p><p>		<h3>Explanation of Each Component</h3><h3></h3></p><p><h3>																						----------------------------------------------</h3><h3></h3></p><p><h3>		• </h3><strong><h3>@Query</h3></strong><h3>: Defines a custom query.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>SELECT</h3></strong><h3>: JPQL keyword to specify the selection of data.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>u</h3></strong><h3>: Alias for the </h3><code><h3>User</h3></code><h3> entity.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>FROM</h3></strong><h3>: JPQL keyword indicating the data source.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>User</h3></strong><h3>: The entity class being queried.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>WHERE</h3></strong><h3>: JPQL keyword to specify conditions.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>u.email</h3></strong><h3>: Field in the </h3><code><h3>User</h3></code><h3> entity.</h3><h3></h3></p><p><h3>		• </h3><strong><h3>= ?1</h3></strong><h3>: Parameter placeholder for the first method argument.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3></p><p></p><p><img src="images/17-9.png" alt="images/17-9.png" /></p><p></p><p></p><p><h3>Explanation of Each Component</h3><h3></h3></p><p><h3>------------------------------------------------</h3><h3></h3></p><p><h3>			• </h3><strong><h3>@Query</h3></strong><h3>: Annotation to define a custom query.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>value =</h3></strong><h3>: Indicates the beginning of the query string.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>&quot;SELECT * FROM users WHERE email = ?1&quot;</h3></strong><h3>: The SQL query string.◇ </h3><strong><h3>SELECT *</h3></strong><h3>: SQL keyword to specify the </h3><h3></h3></p><p><h3>				selection of all columns.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>FROM</h3></strong><h3>: SQL keyword indicating the data source.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>users</h3></strong><h3>: The database table name.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>WHERE</h3></strong><h3>: SQL keyword to specify conditions.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>email</h3></strong><h3>: Column in the </h3><code><h3>users</h3></code><h3> table.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>= ?1</h3></strong><h3>: Parameter placeholder for the first method argument.</h3><h3></h3></p><p><h3>			• </h3><strong><h3>nativeQuery = true</h3></strong><h3>: Specifies that this is a native SQL query.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3></p><p></p><p><h3>Return Type</h3><h3></h3></p><p><h3>========</h3></p><p><h3>						1. </h3><strong><h3>Entity</h3></strong><h3>:</h3><h3></h3></p><p><h3>						• </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>User findById(Long id);</h3></code><h3></h3></p><p><h3>						• </h3><strong><h3>Purpose</h3></strong><h3>: Returns a single entity object. Use this when you expect the query to return exactly one result.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Optional&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>Optional&lt;User&gt; findById(Long id);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Wraps the result in an </h3><code><h3>Optional</h3></code><h3> to handle the case when the result might be null (i.e., no entity found). This is useful for avoiding </h3><code><h3>NullPointerException</h3></code><h3> and for explicitly handling the absence of a result.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>List&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>List&lt;User&gt; findByLastName(String lastName);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a list of entities. Use this when you expect multiple results.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Page&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>Page&lt;User&gt; findByLastName(String lastName, Pageable pageable);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a paginated list of entities. Useful for implementing pagination in your application.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Slice&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>Slice&lt;User&gt; findByLastName(String lastName, Pageable pageable);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Similar to </h3><code><h3>Page</h3></code><h3>, but only fetches a slice of data (partial page) without needing the total count. Useful for infinite scrolling scenarios.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Stream&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>Stream&lt;User&gt; findAllByAgeGreaterThan(int age);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a Java 8 stream of entities, allowing for lazy processing of large datasets.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Collection&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>Collection&lt;User&gt; findByCity(String city);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a collection of entities. Similar to </h3><code><h3>List</h3></code><h3> but more general.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Set&lt;Entity&gt;</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>Set&lt;User&gt; findDistinctByLastName(String lastName);</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a set of entities. Ensures that the results are unique.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>Entity Projection (Interface)</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>List&lt;UserNameOnly&gt; findBy();</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a projection interface, allowing for partial retrieval of entity data.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						• </h3><strong><h3>DTO (Data Transfer Object)</h3></strong><h3>:</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Example</h3></strong><h3>: </h3><code><h3>List&lt;UserDTO&gt; findBy();</h3></code><h3></h3></p><p><h3>						◇ </h3><strong><h3>Purpose</h3></strong><h3>: Returns a DTO object, often used to shape the data returned from the query to meet the specific needs of the client.</h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3></h3><h3></h3></p><p><h3>						Why Use These Return Types?</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Entity</h3></strong><h3>: Directly interact with the entity in the database. Suitable for straightforward CRUD operations.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Optional&lt;Entity&gt;</h3></strong><h3>: Handle potential absence of data gracefully.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>List&lt;Entity&gt;</h3></strong><h3>: Retrieve multiple entities when you expect more than one result.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Page&lt;Entity&gt;</h3></strong><h3>: Efficiently manage large datasets by breaking them into pages. Ideal for pagination.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Slice&lt;Entity&gt;</h3></strong><h3>: Fetch portions of data without needing the total count. Good for scenarios like infinite scrolling.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Stream&lt;Entity&gt;</h3></strong><h3>: Process large datasets in a memory-efficient way.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Collection&lt;Entity&gt;</h3></strong><h3>: More generic than </h3><code><h3>List</h3></code><h3>, but serves a similar purpose.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Set&lt;Entity&gt;</h3></strong><h3>: Ensure uniqueness of results.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>Entity Projection</h3></strong><h3>: Optimize performance by retrieving only the necessary fields.</h3><h3></h3></p><p><h3>						◇ </h3><strong><h3>DTO</h3></strong><h3>: Tailor the query results to fit the specific requirements of the client, enhancing performance and reducing data transfer overhead.</h3></p><p></p><p></p><p>      </p><p>      </p><p>      </p><p>      </p><p>      </p><p>      </p><p>      </p></div>
</body>
</html>
